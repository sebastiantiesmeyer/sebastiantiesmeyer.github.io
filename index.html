<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Audio Oscillator + Scope</title>
  <style>
    :root{--bg:#0f1220;--panel:#171a2b;--ink:#e8ecff;--muted:#9aa3c7;--brand:#6aa2ff;--accent:#34d399;--warn:#f59e0b;}
    *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    body{margin:0;background:linear-gradient(180deg,#0b0e1a,#11142a);color:var(--ink)}
    header{padding:20px 24px;border-bottom:1px solid #232748;background:#101326;position:sticky;top:0;z-index:10}
    h1{margin:0;font-weight:700;font-size:20px;letter-spacing:.3px}
    main{padding:20px;display:grid;grid-template-columns:350px 1fr;gap:20px;align-items:start}
    .panel{background:var(--panel);border:1px solid #232748;border-radius:16px;box-shadow:0 6px 24px rgba(0,0,0,.35)}
    .controls{padding:16px}
    .row{display:grid;grid-template-columns:130px 1fr 84px;gap:10px;align-items:center;margin:10px 0}
    .row label{font-size:12px;color:var(--muted)}
    .row input[type="range"]{width:100%}
    .row input[type="number"]{width:100%;background:#0b0d19;color:var(--ink);border:1px solid #2a3052;border-radius:10px;padding:8px}
    select,button{background:#0b0d19;color:var(--ink);border:1px solid #2a3052;border-radius:10px;padding:8px 10px}
    button.primary{background:var(--brand);border-color:transparent;color:#081020;font-weight:700}
    button.ghost{background:transparent}
    .scope{padding:14px}
    .scope header{display:flex;justify-content:space-between;align-items:center;border:0;background:transparent;padding:0 0 10px 0}
    canvas{width:100%;height:180px;background:#060812;border:1px solid #242847;border-radius:12px}
    .grid{display:grid;grid-template-columns:1fr;gap:16px}
    .grid.two{grid-template-columns:1fr 1fr}
    .stat{font-size:12px;color:var(--muted)}
    footer{padding:16px;text-align:center;color:#7d86ad;font-size:12px}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;font-size:11px;background:#0d1226;border:1px solid #2a3052;color:#b3c0ff}
  </style>
</head>
<body>
  <header>
    <h1>Web Audio Oscillator + 2‑Trace Scope</h1>
  </header>
  <main>
    <!-- LEFT: controls -->
    <section class="panel controls">
      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:8px">
        <button id="btnStart" class="primary">Start Audio</button>
        <button id="btnStop" class="ghost">Stop</button>
        <span id="permStatus" class="badge">mic: ?</span>
      </div>

      <div class="row">
        <label for="inDevice">Input device</label>
        <select id="inDevice"></select>
        <button id="btnRefresh">↻</button>
      </div>

      <hr style="border-color:#232748;border-width:0 0 1px;margin:14px 0"/>

      <h3 style="margin:4px 0 8px">Oscillator (output → Line Out)</h3>
      <div class="row">
        <label for="wave">Waveform</label>
        <select id="wave">
          <option>sine</option>
          <option>square</option>
          <option>triangle</option>
          <option>sawtooth</option>
        </select>
        <span class="stat">type</span>
      </div>
      <div class="row">
        <label for="freq">Frequency (Hz)</label>
        <input id="freq" type="range" min="20" max="20000" value="1000" step="1" />
        <input id="freqNum" type="number" min="1" max="48000" value="1000" />
      </div>
      <div class="row">
        <label for="amp">Amplitude</label>
        <input id="amp" type="range" min="0" max="1" step="0.001" value="0.1" />
        <input id="ampNum" type="number" min="0" max="1" step="0.001" value="0.1" />
      </div>
      <div class="row">
        <label for="dc">DC Offset</label>
        <input id="dc" type="range" min="-0.4" max="0.4" step="0.001" value="0" />
        <input id="dcNum" type="number" min="-0.4" max="0.4" step="0.001" value="0" />
      </div>
      <div class="row">
        <label for="mute">Mute</label>
        <input id="mute" type="checkbox" />
        <span class="stat">⟵ output enable</span>
      </div>

      <h3 style="margin:14px 0 4px">Sweep</h3>
      <div class="row">
        <label for="sweepMin">Start (Hz)</label>
        <input id="sweepMin" type="number" value="100" />
        <span></span>
      </div>
      <div class="row">
        <label for="sweepMax">Stop (Hz)</label>
        <input id="sweepMax" type="number" value="5000" />
        <span></span>
      </div>
      <div class="row">
        <label for="sweepRate">Rate (Hz/s)</label>
        <input id="sweepRate" type="number" value="500" />
        <button id="btnSweep">Start sweep</button>
      </div>

      <hr style="border-color:#232748;border-width:0 0 1px;margin:14px 0"/>

      <h3 style="margin:4px 0 8px">Scope settings</h3>
      <div class="row">
        <label for="timebase">Time/div (ms)</label>
        <input id="timebase" type="range" min="0.1" max="50" step="0.1" value="2" />
        <input id="timebaseNum" type="number" min="0.1" max="50" step="0.1" value="2" />
      </div>
      <div class="row">
        <label for="trigLevel">Trigger level</label>
        <input id="trigLevel" type="range" min="-1" max="1" step="0.01" value="0" />
        <input id="trigSlope" type="checkbox" />
        <span class="stat">↑/↓ slope</span>
      </div>
      <div class="row">
        <label for="fftSize">FFT size (draw)</label>
        <select id="fftSize">
          <option>2048</option>
          <option selected>4096</option>
          <option>8192</option>
          <option>16384</option>
        </select>
        <span class="stat">resolution</span>
      </div>
      <p class="stat">Tip: to use a **line‑in**, disable echo cancellation in the permission prompt and choose your device above.</p>
    </section>

    <!-- RIGHT: scopes -->
    <section class="panel scope">
      <header>
        <div>
          <strong>Output (post‑gain) — CH A</strong>
          <div class="stat" id="outStats">…</div>
        </div>
        <div>
          <strong>Input (from audio device) — CH B</strong>
          <div class="stat" id="inStats">…</div>
        </div>
      </header>
      <div class="grid two">
        <canvas id="canvasOut" width="1100" height="220"></canvas>
        <canvas id="canvasIn" width="1100" height="220"></canvas>
      </div>
      <div class="grid" style="margin-top:12px">
        <canvas id="canvasSpectrum" width="1100" height="220"></canvas>
      </div>
    </section>
  </main>

  <footer>
    Works in modern Chromium/Firefox/Safari. Audio is AC‑coupled by most OS/hardware; true DC isn’t supported.
  </footer>

<script>
(() => {
  let ac, osc, outGain, dcOffset, merger, outAnalyser, inAnalyser, inputNode, mediaStream;
  let drawId = 0, sweeping = false;

  const $ = (id) => document.getElementById(id);
  const els = {
    start: $('btnStart'), stop: $('btnStop'), refresh: $('btnRefresh'), perm: $('permStatus'),
    wave: $('wave'), freq: $('freq'), freqNum: $('freqNum'), amp: $('amp'), ampNum: $('ampNum'), dc: $('dc'), dcNum: $('dcNum'), mute: $('mute'),
    inDevice: $('inDevice'),
    sweepMin: $('sweepMin'), sweepMax: $('sweepMax'), sweepRate: $('sweepRate'), btnSweep: $('btnSweep'),
    timebase: $('timebase'), timebaseNum: $('timebaseNum'), trigLevel: $('trigLevel'), trigSlope: $('trigSlope'), fftSize: $('fftSize'),
    canvasOut: $('canvasOut'), canvasIn: $('canvasIn'), canvasSpectrum: $('canvasSpectrum'),
    outStats: $('outStats'), inStats: $('inStats')
  };

  function syncPair(a, b){
    const sync = (src, dst) => () => { dst.value = src.value; }; a.addEventListener('input', sync(a,b)); b.addEventListener('input', sync(b,a));
  }
  syncPair(els.freq, els.freqNum); syncPair(els.amp, els.ampNum); syncPair(els.dc, els.dcNum); syncPair(els.timebase, els.timebaseNum);

  async function initAudio(){
    if (!ac) ac = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });

    // OUTPUT
    osc = ac.createOscillator();
    osc.type = els.wave.value;
    osc.frequency.value = parseFloat(els.freq.value);

    outGain = ac.createGain();
    outGain.gain.value = parseFloat(els.amp.value);

    dcOffset = ac.createConstantSource();
    dcOffset.offset.value = parseFloat(els.dc.value);

    merger = ac.createGain(); // sums osc + DC

    outAnalyser = ac.createAnalyser();
    outAnalyser.fftSize = parseInt(els.fftSize.value);

    // wire: osc + dc -> merger -> analyser -> destination
    osc.connect(merger);
    dcOffset.connect(merger);
    merger.connect(outGain);
    outGain.connect(outAnalyser);
    outGain.connect(ac.destination);

    // INPUT
    await refreshDevices();
    await startInput();

    osc.start();
    dcOffset.start();
    draw();
  }

  async function refreshDevices(){
    const devices = await navigator.mediaDevices.enumerateDevices();
    const inputs = devices.filter(d => d.kind === 'audioinput');
    els.inDevice.innerHTML = inputs.map(d => `<option value="${d.deviceId}">${d.label || 'Input ' + d.deviceId}</option>`).join('');
  }

  async function startInput(){
    if (mediaStream) mediaStream.getTracks().forEach(t=>t.stop());
    const constraints = { audio: { deviceId: els.inDevice.value ? {exact: els.inDevice.value} : undefined, echoCancellation: false, noiseSuppression: false, autoGainControl: false } };
    try{
      mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
      els.perm.textContent = 'mic: ok';
      inputNode = ac.createMediaStreamSource(mediaStream);
      inAnalyser = ac.createAnalyser();
      inAnalyser.fftSize = parseInt(els.fftSize.value);
      inputNode.connect(inAnalyser);
    }catch(err){
      console.error(err);
      els.perm.textContent = 'mic: blocked';
      alert('Microphone/line-in permission denied. Allow access to use the scope input.');
    }
  }

  function stopAudio(){
    if (drawId) cancelAnimationFrame(drawId);
    if (osc) { try{ osc.stop(); }catch{}; osc.disconnect(); }
    if (dcOffset) { try{ dcOffset.stop(); }catch{}; dcOffset.disconnect(); }
    if (outGain) outGain.disconnect();
    if (merger) merger.disconnect();
    if (inputNode) inputNode.disconnect();
    if (mediaStream) mediaStream.getTracks().forEach(t=>t.stop());
    ac && ac.close();
    ac = null;
  }

  // UI handlers
  els.start.onclick = async () => { await initAudio(); };
  els.stop.onclick = () => { stopAudio(); };
  els.refresh.onclick = () => refreshDevices();
  els.inDevice.onchange = () => startInput();
  els.wave.onchange = () => { if (osc) osc.type = els.wave.value; };
  els.freq.oninput = els.freqNum.oninput = () => { if (osc) osc.frequency.setTargetAtTime(parseFloat(els.freq.value), ac.currentTime, 0.01); };
  els.amp.oninput = els.ampNum.oninput = () => { if (outGain) outGain.gain.setTargetAtTime(parseFloat(els.amp.value), ac.currentTime, 0.01); };
  els.dc.oninput = els.dcNum.oninput = () => { if (dcOffset) dcOffset.offset.setTargetAtTime(parseFloat(els.dc.value), ac.currentTime, 0.01); };
  els.mute.onchange = () => { if (outGain) outGain.gain.setTargetAtTime(els.mute.checked ? 0 : parseFloat(els.amp.value), ac.currentTime, 0.005); };
  els.fftSize.onchange = () => {
    const n = parseInt(els.fftSize.value); if (outAnalyser) outAnalyser.fftSize = n; if (inAnalyser) inAnalyser.fftSize = n;
  };

  els.btnSweep.onclick = () => {
    sweeping = !sweeping;
    els.btnSweep.textContent = sweeping ? 'Stop sweep' : 'Start sweep';
    if (!sweeping) return;
    const f0 = parseFloat(els.sweepMin.value), f1 = parseFloat(els.sweepMax.value), rate = parseFloat(els.sweepRate.value);
    let dir = 1; let f = f0; const step = () => {
      if (!sweeping || !osc) return; f += dir * rate/30; if (f >= f1) { f=f1; dir=-1; } if (f <= f0) { f=f0; dir=1; }
      els.freq.value = els.freqNum.value = f.toFixed(1); osc.frequency.setTargetAtTime(f, ac.currentTime, 0.01); requestAnimationFrame(step);
    }; step();
  };

  function draw(){
    const ctxO = els.canvasOut.getContext('2d');
    const ctxI = els.canvasIn.getContext('2d');
    const ctxS = els.canvasSpectrum.getContext('2d');

    const width = els.canvasOut.width, height = els.canvasOut.height;

    const drawWave = (ctx, analyser, colorMain) => {
      if (!analyser) return;
      const buf = new Float32Array(analyser.fftSize);
      analyser.getFloatTimeDomainData(buf);
      // Triggering
      const samplesPerDiv = (parseFloat(els.timebase.value) / 1000) * ac.sampleRate; // ms/div, 10 divs across
      const total = Math.min(buf.length, Math.floor(samplesPerDiv * 10));
      let start = 0;
      const trig = parseFloat(els.trigLevel.value);
      const rising = !!els.trigSlope.checked;
      for (let i=1;i<total;i++){
        const a = buf[i-1], b = buf[i];
        if (rising ? (a < trig && b >= trig) : (a > trig && b <= trig)) { start = i; break; }
      }
      ctx.clearRect(0,0,width,height);
      ctx.strokeStyle = colorMain; ctx.lineWidth = 2; ctx.beginPath();
      const step = Math.max(1, Math.floor((total)/width));
      for (let x=0, i=start; x<width && i<start+total; x++, i+=step){
        const y = (0.5 - 0.45*buf[i]) * height; // scale
        if (x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      // grid
      ctx.strokeStyle = 'rgba(120,140,200,0.25)'; ctx.lineWidth = 1;
      for (let d=1; d<10; d++){ const gx = d*width/10; ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,height); ctx.stroke();
        const gy = d*height/10; ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(width,gy); ctx.stroke(); }
    };

    const drawSpectrum = () => {
      if (!inAnalyser) return;
      const N = inAnalyser.frequencyBinCount; const arr = new Uint8Array(N); inAnalyser.getByteFrequencyData(arr);
      ctxS.clearRect(0,0,els.canvasSpectrum.width, els.canvasSpectrum.height);
      ctxS.fillStyle = '#0b0f22'; ctxS.fillRect(0,0,els.canvasSpectrum.width, els.canvasSpectrum.height);
      ctxS.fillStyle = '#6aa2ff';
      const W = els.canvasSpectrum.width, H = els.canvasSpectrum.height;
      for (let i=0;i<N;i++){ const v = arr[i]/255; const x = i*W/N; const y = H*(1-v); ctxS.fillRect(x,y, W/N, H);
      }
    };

    // Stats (RMS + est. frequency via autocorrelation)
    function computeStats(analyser){
      if (!analyser) return {rms:0, freq:0};
      const buf = new Float32Array(analyser.fftSize); analyser.getFloatTimeDomainData(buf);
      let sum = 0; for (let i=0;i<buf.length;i++) sum += buf[i]*buf[i];
      const rms = Math.sqrt(sum/buf.length);
      // Auto-correlation for basic pitch/freq estimate
      let bestOfs = 0, best = 0; const maxLag = Math.floor(buf.length/2);
      for (let lag=1; lag<maxLag; lag++){
        let c=0; for (let i=0; i<maxLag; i++) c += buf[i]*buf[i+lag];
        if (c>best){ best=c; bestOfs=lag; }
      }
      const freq = bestOfs ? ac.sampleRate/bestOfs : 0;
      return {rms, freq};
    }

    const loop = () => {
      drawWave(ctxO, outAnalyser, '#34d399');
      drawWave(ctxI, inAnalyser, '#6aa2ff');
      drawSpectrum();
      const o = computeStats(outAnalyser), i = computeStats(inAnalyser);
      els.outStats.textContent = `RMS: ${o.rms.toFixed(3)}  |  ~Freq: ${o.freq.toFixed(1)} Hz`;
      els.inStats.textContent  = `RMS: ${i.rms.toFixed(3)}  |  ~Freq: ${i.freq.toFixed(1)} Hz`;
      drawId = requestAnimationFrame(loop);
    };
    loop();
  }
})();
</script>
</body>
</html>
